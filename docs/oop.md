
- [类与对象](#类与对象)
- [继承](#继承)
- [封装](#封装)
- [抽象类和方法](#抽象类和方法)
- [修饰符](#修饰符)
- [Object类](#object类)
- [OO设计要略](#oo设计要略)
- [异常](#异常)

# 类与对象

类是Java的基本元素结构。类定义一种新的引用类型。
类的定义包括一个签名和一个主体。

成员包括：类字段、类方法、实例字段、实例方法。  
成员可以使用访问修饰符 public、protected、private 。隐藏成员是一种面向对象设计技术，叫做数据封装。

超类（父类）+子类  
子类继承超类的成员，可以声明新成员，或使用新的实现覆盖继承的方法。  
类还可能实现一个或多个接口。接口类似类，但其方法没有实现主体。从Java8之后，可以使用default指定方法的默认实现。类必须为接口的非默认方法提供实现主体。实现某个接口的类的实例，也是这个接口类型的实例。

```java
// 一个类的声明示例
public class Integer extends Number implements Serializable, Comparable {}
```

类的修饰符：public protected abstract final strictfp  
字段修饰符：public protected private static final transient volatile

方法签名中不显示隐式参数this。在类的内部，一般也很少用到，除非可能引起误解，例如：子类与父类的同名方法，类的成员字段与局部变量同名。

构造方法是用于初始化实例中的字段。如果未明确指定，编译器会提供一个默认构造方法。  
构造方法与类同名。构造方法不指定返回值类型。构造方法也不能返回任何值。  
构造方法可以有多个，编译器会根据参数的数量和类型自动选择合适的构造方法。  
在一个构造方法中可以调用另一个构造方法，这样可以节约重复代码。  
当使用new运算符时，先分配内存存储新建的对象实例，然后调用构造方法并传入参数，构造方法使用这些参数初始化对象。

类也有构造方法，但对开发者不可见，在类文件中（使用javap查看），其名称是`<clint>`。

开发者可以通过“静态初始化程序”初始化类的字段。“静态初始化程序”由static关键字和随后的花括号中的代码组成。  
类可以有多个静态初始化程序。
```java
public class TrigCircle {
    private static final int NUMPTS = 500;
    private static double sth = 0.0;

    // 静态初始化代码
    static {
        sth = 1.0;
    }
}
```

实例也有“实例初始化程序”，与类的“静态初始化程序”相似。实例也可以有多个实例初始化程序。不过现实中很少需要使用。
```java
public class TrigCircle {
    private int[] data = new int[10];
    { for(int i=0; i< 10;i++) data[i]=i;}
}
```

# 继承

继承是面向对象编程范式的核心。

类只能继承一个类。

使用final修饰的类无法被继承。

每个自定义的类都有超类，如果没有指定，那超类就是 java.lang.Object 。 Object是特殊的类，其没有超类。
Java中的所有类能表示为一个根为Object的树状图。

子类的构造方法中，可以通过 `super()` 调用父类的构造方法，但也只能在构造方法中调用，而且必须在构造方法的第一句就调用。  
实际上，Java会保证 `super()` 方法一定会被调用，不是明确调用就是隐式调用。  
父类的构造方法又会继续调用父类的父类的构造方法，形成构造方法链，直到顶端的Object为止。  
如果父类没有定义无参数的构造方法，那么其所有子类必须显式调用父类的构造方法。

如果类没有定义任何构造方法，默认会为其提供一个默认的无参数的构造方法。  
如果创建的public类不能公开实例话，就应该至少声明一个非public 的构造方法，以此避免插入默认的public构造方法。从不会实例化的类（如 java.lang.Math ）应该定义一个private构造函数。


字段的字段，如果与超类的字段同名，则会“遮盖”超类的字段。  
子类和方法，如果与超类的方法名称相同、参数相同、返回值相同，则会“覆盖”超类的方法。（覆盖方法的返回值类型可以是原方法返回值的子类，这叫协变返回。）  
调用被遮盖或被覆盖的字段或方法，可以通过`super.something`进行。但调用被覆盖的方法，只能在覆盖方法的内部进行。
> 注意，“遮盖”和“覆盖”的区别。遮盖只是默认看不到，覆盖是真的没有了。


子类的每个实例都包含一个完整的超类实例，其中包括所有不可访问的字段和方法，但不继承构造方法。

对象可以转换成超类类型，或任何祖先类类型。这是放大转换，不用校正。这又称里氏替换原则。  
对象可以转换为子类类型。这是缩小转换，需要校正。解释器运行时会做检查，确保转换有效，否则会抛出ClassCastException。

数组的转换有自己的规则。首先，任何数组都能放大转换成Object对象，带校正的缩小转换再把这个对象转为数组。  
两个数组的“基类型”是可以互相转换的引用类型，那么数组可以转换为另一个类型的数组。  
注意：数组的转换规则只能适用于由对象或数组组成的数组，基本类型的数组不能转换为任何其他数组类型。
```java
Object o = new int[] {1,2,3}; // 数组转为Object
int[] a = (int[])o; // Object转为数组
```

# 封装

将数据隐藏在类中，只能通过类的方法进行操作，这叫封装。  
操作方法的通用约定，一般以 get 和 set 开头，如果字段是布尔型，会使用 is 开头。例如： getRadius(), setRadius(), isReadable()。


Java不直接支持对包的访问控制，访问控制限制在类和成员层次。  
访问控制符：public、protected、private、无（默认包访问）。
访问规则
- **类的成员在类的主体内使用可以访问。**
- **类的public成员，在任何地方都可以访问。最宽松。**
- **类的private成员，只能在类的内部访问。最严格。**
- **类的protected成员，能被子类访问，也能被同包的类访问。**
- **不使用任何修饰符的成员，只能被同包的类访问。**

使用public声明的字段必须使用final，确保是常量或不能修改的对象。

设计API时，需要注意访问限制，先严后送。因为提高访问限制会导致不向后兼容。

# 抽象类和方法

抽象方法，只定义签名，不提供实现。

只要类中有一个抽象方法，则该类自动成为抽象类，而且必须声明为 abstract class，否则会编译报错。  
抽象类无法实例化。  
抽象类的子类必须覆盖超类的每个抽象方法并提供实现，这样才能实例化。这种类一般叫做具体子类。  
抽象类的子类没有全部实现父类的抽象方法，那么该子类还是抽象类。  
使用static、private和final声明的方法不能是抽象方法。  
final类中不能含有抽象方法。


# 修饰符

| 修饰符 | 用于 | 意义 |
|-------|-----|------|
| abstract | 类 | 抽象类，不能直接实例化 |
| abstract | 接口 | 抽象接口，可选 |
| abstract | 方法 | 抽象方法，没有主体 |
| default | 方法 | 接口方法的默认实现 |
| final | 类 | 无法继承 |
| final | 方法 | 不能覆盖 |
| final | 字段 | 字段值不可改变。static final 多用于声明常量 |
| final | 变量 | 值不可变 |
| native | 方法 | 方法使用其他语言实现 |
| 无（包） | 类 | 没声明为public的类只能在包中访问 |
| 无（包） | 接口 | 没声明为public的接口只能在包中访问 |
| 无（包） | 成员 | 没声明为private、protected或public的成员只能在包中访问 |
| private | 成员 | 只能在类的主体中访问 |
| protected | 成员 | 只能在类的主体和子类中访问 |
| public | 类 | 公开 |
| public | 接口 | 公开 |
| public | 成员 | 公开 |
| strictfp | 类 | 类的所有方法都隐式声明为strictfp |
| strictfp | 方法 | 严格遵守IEEE754标准执行浮点计算，很少使用 |
| static | 类 | 使用static声明的内部类是顶层类，而不是所在类的成员 |
| static | 方法 | 类方法 |
| static | 字段 | 类字段 |
| static | 初始化程序 | 加载类时运行 |
| synchronized | 方法 | 对类或实例执行非院子操作，使用排他锁进行修改 |
| transient | 字段 | 字段不是对象持久化的一部分，不随对象持久化 |
| volatile | 字段 | 字段能被异步线程访问，有时可代替synchronized |

# Object类

所有类都直接或间接扩展 java.lang.Object 类。

Object的重要方法
- toString() 返回对象的文本表示格式，在 System.out.print() 方法中会被自动调用。 Object类的toString()方法返回的字符串由对象所属的类名和对象的十六进制形式哈希码（由hashCode()计算得到）组成。
- equals() 测试两个对象是否相等。Object的equals()直接==测试。Object的子类可以覆盖equals()方法。
- hashCode() 返回一个整数，用于哈希表数据结构。在equals()中也被使用，不同的对象具有不同的哈希码。如果覆盖了equals()，就必须覆盖hashCode()。
- clone() 复制自身，返回新对象。clone()不常使用，因为只有类实现了java.lang.Cloneable接口，该方法才有效，另外，必须在类中覆盖 clone() 方法，并设置为 public 才行。

# OO设计要略

常量可以在接口中定义，每个实现接口的类都会继承这个常量。但除了 ObjectStreamConstants 外，并不推荐这么做。  
更好的方式是在类中定义常量，使用是要输入完整的类名和常量名。

抽象类并非完全抽象，可以包含部分实现，供子类使用。很多子类可以沿用抽象超类提供的方法实现。  
接口方法也并非完全没有实现，可以通过default提供默认实现。  
在抽象类和接口的选择问题上，选择时主要考虑兼容性：当接口是公开API的一部分时，在接口中添加一个新的强制方法，会导致所有实现这个接口的类出问题；而抽象类则不会，可以放心添加非抽象方法。一般来说，需要制定API规范时，推荐选择接口。

继承不是唯一可用的面向对象设计技术。对象还可以包含其他对象的引用，这叫做合成（composition）。与此相关的一个重要技术是委托（delegation）：某个特定类型的对象保存一个引用，指向一个兼容类型的附属对象，而且把所有的操作都交给这个附属对象完成。

子类最好使用数据访问器方法（get/set方法）访问父类字段的数据，而不是直接访问字段本身。

单例模式是参见的设计模式之一，虽然经常被过度使用。但如果一个程序中有太多单例类，往往表明代码设计的不好。  
单例模式有一些弊端：难测试、难与其他类分开。  
单例模式一般用于管理配置，一般框架会提供实现代理的代码（一般是依赖注入），而不用自己动手。

> 设计模式参见 GoF 的《设计模式》。

# 异常

异常是对象，这个对象的类型是 java.lang.Throwable，更准确的说是 Throwable 类的子类，更具体地描述发生的异常是什么类型。  
Throwable有两个标准子类：Error和Exception。Error类的子类表示不可恢复的问题，如内存耗尽，这种异常一般不用捕获，称为“未检异常”。Exception类的子类表示可以恢复的异常，如数组索引越界，需要捕获并处理。  
Throwablle类及其所有子类都包含一个String字段，描述发生的异常情况，可以通过 getMessage() 读取。  
Exception有4个公开的构造函数，自定义异常类时需要实现全部4个构造方法。

要避免两种反模式：捕获而不处理、捕获后又重新抛出。
